实现功能：
* 消息是个结构体
> 不需要做任何的转换即可使用
* 响应式编程
> rx目录
* 分为2个区，每个区有2个服务
* 当没有服务消费时，消息不丢失；服务重启后可继续消费
* 没有区中的服务是高可用的，当当前处理的服务停止时，另一个服务可工作
* 中间件不使用默认的配置；自定义中间件配置，并与管道绑定



#### 总结
1. 为了互操作性，格式采用application/json
2. 提高吞吐量，采用分区的模式
```
# 需要增加以下配置，才会分区
partitionKeyExpression: payload
```
3. 为了实现高可用性，每个分区至少2个服务   
  * rabbitmq: 执行时，同一分区的服务间采用轮询的方式获得到消息
  * kafka:执行时，同一分区的服务间只有一个获得到消息
4. 防止消息binder的中间件配置与其他功能冲突（bus 也会用到消息中间件），所以采用自定义配置，然后与管道绑定
5. 由于采用了消息订阅的方式，需要先启动消费端来创建消费管道，否则由于不存在消费管道造成之前的消息无法接受
6. 为了实现消费端关闭后消息仍然保存在管道中防止丢消息，所以需要以下配置；这样的话，会创建持久化的queue
```aidl
group: 组名
```
